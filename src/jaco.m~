function [j,ip] = jaco(fun,x0,V,verbose,order)
% Compute the 1st or 2nd order partial (numerical) derivates of a function
%
% usage: [j,ip] = jaco(fun,x0,V,verbose,order)
%
% (order 1:) Compute the 1st order partial derivatives (parameter gradients) 
% for a model using:
%
% j(ip,:) = ( f(x(ip)+h)  - f(x(ip)-h) )  / (2 * h)
%
% (order 2:) Compute the 2nd order derivatives:
%
% j(ip,:) = [ (f0 - f1) / 2 / d ] ./ [ (f0 - 2 * fx + f1) / d ^ 2 ]
%
%
% note:
% - when length(fun(x0)) == length(x0), the
%
% AS2019

if nargin < 5 || isempty(order)
    order = 1;
end

if nargin < 4 || isempty(verbose)
    verbose = 0;
end

IS = fun;
P  = x0(:);

% if nargin == 3; ip = find(V(:));
% else;           ip = 1:length(x0);
% end

if nargin >= 3; ip = ~~(V(:));
else;           ip = 1:length(x0);
end

j  = jacf(IS,P,ip,verbose,V,order);

j(isnan(j)) = 0;

end



function j = jacf(IS,P,ip,verbose,V,order)

% Compute the Jacobian matrix using variable step-size
n  = 0;
warning off ;

if verbose
    switch order
        case 1 ; fprintf('Copmuting 1st order pd (Gradient/Jacobian)\n');
        case 2 ; fprintf('Computing 2nd order pd (Curvature)\n');
    end
end

%f0    = feval(IS,P);
f0    = spm_cat( feval(IS,P) );
fx    = f0;
j     = zeros(length(P),length(f0(:))); % n param x n output
for i = 1:length(P)
    if ip(i)
        
        % Print progress
        n = n + 1;
        if verbose
            if n > 1; fprintf(repmat('\b',[1,length(str)])); end
            str  = sprintf('Computing Gradients [ip %d / %d]',n,length(find(ip)));
            fprintf(str);
        end
        
        % Compute Jacobi: A(j,:) = ( f(x+h) - f(x-h) ) / (2 * h)
        P0     = P;
        P1     = P;
        d      = P0(i) * V(i);
        
        if d == 0
            d = 0.01;
        end
        
        P0(i)  = P0(i) + d  ;
        P1(i)  = P1(i) - d  ;
                
        f0     = spm_vec(spm_cat(feval(IS,P0)));
        f1     = spm_vec(spm_cat(feval(IS,P1)));
        j(i,:) = (f0 - f1) / (2 * d);
        
        if order == 2
            % Alternatively, include curvature
            deriv1 = (f0 - f1) / 2 / d;
            deriv2 = (f0 - 2 * fx + f1) / d ^ 2;
            j(i,:) = deriv1 ./ deriv2;
        end
    end
end

warning on;
if verbose
    fprintf('\n');
end

end